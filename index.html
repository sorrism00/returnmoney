<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>회수금 계산기</title>

  <!-- PWA 관련 메타 태그 -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="계산기">
  <!-- 업로드된 이미지 파일 URL로 변경 -->
  <link rel="apple-touch-icon" sizes="180x180" href="https://placehold.co/180x180/0f172a/fff?text=CC">
  <meta name="theme-color" content="#0f172a">
  
  <!-- manifest.json 파일 링크 -->
  <link rel="manifest" href="/manifest.json">

  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React & ReactDOM CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Babel CDN for JSX support -->
  <script src="https://unpkg.com/@babel/standalone/babel.js"></script>

  <style>
    /* Prevent number input spin buttons */
    input[type='text'].no-spinner::-webkit-outer-spin-button,
    input[type='text'].no-spinner::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type='text'].no-spinner {
      -moz-appearance: textfield;
    }
  </style>
</head>
<body class="bg-slate-900">

<div id="root"></div>

<script type="text/babel">
  // 화폐 단위를 정의합니다.
  const denominations = [
    { name: '오만원권', value: 50000, type: 'bill' },
    { name: '만원권', value: 10000, type: 'bill' },
    { name: '오천원권', value: 5000, type: 'bill' },
    { name: '천원권', value: 1000, type: 'bill' },
    { name: '오백원', value: 500, type: 'coin' },
    { name: '백원', value: 100, type: 'coin' },
    { name: '오십원', value: 50, type: 'coin' },
    { name: '십원', value: 10, type: 'coin' },
  ];

  // 숫자를 한국 형식(콤마)으로 변환하는 함수
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('ko-KR').format(amount);
  };

  function App() {
    const { useState, useMemo } = React;

    // 각 화폐 단위의 수량을 저장하는 상태 (개수 입력용)
    const [quantities, setQuantities] = useState(() =>
      denominations.reduce((acc, denom) => ({ ...acc, [denom.value]: '' }), {})
    );
    // 각 화폐 단위의 금액을 저장하는 상태 (금액 입력용)
    const [denominationAmounts, setDenominationAmounts] = useState(() =>
      denominations.reduce((acc, denom) => ({ ...acc, [denom.value]: '' }), {})
    );

    // 새로운 항목들을 위한 상태
    const [prevVaultBalance, setPrevVaultBalance] = useState('');
    const [coinReplenishment, setCoinReplenishment] = useState(''); // 양수 값 저장
    const [slipDiscrepancy, setSlipDiscrepancy] = useState('');     // 양수 값 저장
    const [slipDiscrepancySign, setSlipDiscrepancySign] = useState('none'); // 'plus', 'minus', 'none'

    // 지폐/동전 개수 입력 처리 함수
    const handleQuantityChange = (value, denom) => {
      const cleanValue = value.replace(/[^0-9]/g, '');
      const newQuantity = cleanValue === '' ? '' : parseInt(cleanValue, 10);
      const newAmount = newQuantity === '' ? '' : newQuantity * denom.value;

      setQuantities(prev => ({ ...prev, [denom.value]: cleanValue }));
      setDenominationAmounts(prev => ({ ...prev, [denom.value]: newAmount === '' ? '' : String(newAmount) }));
    };

    // 지폐/동전 금액 입력 처리 함수
    const handleAmountChange = (value, denom) => {
      const cleanValue = value.replace(/[^0-9]/g, '');
      const newAmount = cleanValue === '' ? '' : parseInt(cleanValue, 10);
      // denom.value가 0인 경우는 없지만, 안전을 위해 예외 처리
      const newQuantity = (newAmount === '' || denom.value === 0) ? '' : Math.floor(newAmount / denom.value);

      setDenominationAmounts(prev => ({ ...prev, [denom.value]: cleanValue }));
      setQuantities(prev => ({ ...prev, [denom.value]: newQuantity === '' ? '' : String(newQuantity) }));
    };
    
    // 모든 입력 필드를 초기화하는 함수
    const handleReset = () => {
      setQuantities(
        denominations.reduce((acc, denom) => ({ ...acc, [denom.value]: '' }), {})
      );
      setDenominationAmounts(
        denominations.reduce((acc, denom) => ({ ...acc, [denom.value]: '' }), {})
      );
      setPrevVaultBalance('');
      setCoinReplenishment('');
      setSlipDiscrepancy('');
      setSlipDiscrepancySign('none');
    };

    // 금액 계산 (최적화를 위해 useMemo 사용)
    const totals = useMemo(() => {
      let billTotal = 0;
      let coinTotal = 0;
      let denominationGrandTotal = 0; // 지폐와 동전의 총 합계

      denominations.forEach(denom => {
        // denominationAmounts 상태를 사용하여 총액 계산 (개수 또는 금액 입력 반영)
        const amount = parseInt(denominationAmounts[denom.value] || '0') || 0;
        
        if (denom.type === 'bill') {
          billTotal += amount;
        } else {
          coinTotal += amount;
        }
        denominationGrandTotal += amount;
      });

      const parsedPrevVaultBalance = parseInt(prevVaultBalance || '0') || 0;
      const parsedCoinReplenishment = parseInt(coinReplenishment || '0') || 0;
      const parsedSlipDiscrepancy = parseInt(slipDiscrepancy || '0') || 0;

      let finalSlipDiscrepancyValue = 0;
      if (slipDiscrepancySign === 'plus') {
        finalSlipDiscrepancyValue = parsedSlipDiscrepancy;
      } else if (slipDiscrepancySign === 'minus') {
        finalSlipDiscrepancyValue = -parsedSlipDiscrepancy;
      }

      // 마감 후 금고 잔액 = 마감 전 금고 잔액 + (지폐 동전 합계) - 동전보충 + 전표상이
      const grandTotal = parsedPrevVaultBalance + denominationGrandTotal - parsedCoinReplenishment + finalSlipDiscrepancyValue;
      
      return {
        billTotal,
        coinTotal,
        denominationGrandTotal, // 지폐와 동전의 합계
        prevVaultBalance: parsedPrevVaultBalance,
        coinReplenishment: parsedCoinReplenishment,
        slipDiscrepancy: finalSlipDiscrepancyValue,
        grandTotal // 최종 마감 후 금고 잔액
      };
    }, [quantities, denominationAmounts, prevVaultBalance, coinReplenishment, slipDiscrepancy, slipDiscrepancySign]);

    // 동전보충 전용 컴포넌트
    const CoinReplenishmentItem = ({ value, onChange }) => {
      return (
        <div className="flex items-center justify-between py-1 border-b border-gray-300 last:border-b-0">
          <span className="text-gray-700 text-sm font-medium">동전보충</span>
          <div className="flex items-center space-x-1">
            {value !== '' && <span className="font-semibold text-red-500 text-sm">-</span>}
            <input
              type="text"
              inputMode="numeric"
              placeholder="0"
              // 항상 포맷된 금액으로 표시
              value={value === '' ? '' : formatCurrency(parseInt(value || '0'))}
              onChange={(e) => onChange(e.target.value.replace(/[^0-9]/g, ''))}
              className="w-32 h-8 text-right text-sm font-bold bg-gray-200 rounded-md p-1 focus:outline-none focus:ring-2 focus:ring-blue-500 no-spinner text-red-500"
            />
            <span className="text-gray-500 text-xs">원</span>
          </div>
        </div>
      );
    };

    // 전표상이 전용 컴포넌트
    const SlipDiscrepancyItem = ({ value, type, onChange, onTypeChange }) => {
      const textColor = type === 'minus' ? 'text-red-500' : (type === 'plus' ? 'text-blue-500' : 'text-gray-900');
      const prefix = type === 'minus' ? '-' : (type === 'plus' ? '+' : '');

      return (
        <div className="flex items-center justify-between py-1 border-b border-gray-300 last:border-b-0">
          {/* Label and buttons moved here */}
          <div className="flex items-center space-x-2">
            <span className="text-gray-700 text-sm font-medium">전표상이</span>
            <button
              onClick={() => onTypeChange(type === 'minus' ? 'none' : 'minus')}
              className={`px-2 py-1 rounded-md text-sm font-bold ${type === 'minus' ? 'bg-red-500 text-white' : 'bg-gray-200 text-gray-700'} hover:opacity-80 transition-opacity`}
            >
              -
            </button>
            <button
              onClick={() => onTypeChange(type === 'plus' ? 'none' : 'plus')}
              className={`px-2 py-1 rounded-md text-sm font-bold ${type === 'plus' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700'} hover:opacity-80 transition-opacity`}
            >
              +
            </button>
          </div>
          
          {/* Input field and '원' */}
          <div className="flex items-center space-x-1">
            {prefix && value !== '' && <span className={`font-semibold text-sm ${textColor}`}>{prefix}</span>}
            <input
              type="text"
              inputMode="numeric"
              placeholder="0"
              // 항상 포맷된 금액으로 표시
              value={value === '' ? '' : formatCurrency(parseInt(value || '0'))}
              onChange={(e) => onChange(e.target.value.replace(/[^0-9]/g, ''))}
              className={`w-32 h-8 text-right text-sm font-bold bg-gray-200 rounded-md p-1 focus:outline-none focus:ring-2 focus:ring-blue-500 no-spinner ${textColor}`}
            />
            <span className="text-gray-500 text-xs">원</span>
          </div>
        </div>
      );
    };

    // UI 구성 요소 렌더링 (지폐/동전 항목)
    const renderDenominationItem = (denom) => {
      const [isFocusedQuantity, setIsFocusedQuantity] = useState(false);
      const [isFocusedAmount, setIsFocusedAmount] = useState(false);

      return (
        <div key={denom.value} className="flex items-center justify-between py-1 border-b border-gray-300 last:border-b-0">
          <div className="flex-1 pr-1 min-w-[50px]">
            <span className="text-gray-700 text-sm font-medium whitespace-nowrap overflow-hidden text-ellipsis">{denom.name}</span>
          </div>
          
          <div className="flex items-center space-x-1 flex-shrink-0">
            <input
              type="text"
              inputMode="numeric"
              placeholder="0"
              value={isFocusedQuantity ? quantities[denom.value] : (quantities[denom.value] === '' ? '' : formatCurrency(parseInt(quantities[denom.value] || '0')))}
              onFocus={() => setIsFocusedQuantity(true)}
              onBlur={() => setIsFocusedQuantity(false)}
              onChange={(e) => handleQuantityChange(e.target.value, denom)}
              className="w-14 h-8 text-right text-gray-800 text-sm font-bold bg-gray-200 rounded-md p-1 focus:outline-none focus:ring-2 focus:ring-blue-500 no-spinner"
            />
            <span className="text-gray-500 text-xs">개</span>
          </div>

          <div className="flex items-center space-x-1 flex-shrink-0 ml-2">
            <input
              type="text"
              inputMode="numeric"
              placeholder="0"
              value={isFocusedAmount ? denominationAmounts[denom.value] : (denominationAmounts[denom.value] === '' ? '' : formatCurrency(parseInt(denominationAmounts[denom.value] || '0')))}
              onFocus={() => setIsFocusedAmount(true)}
              onBlur={() => setIsFocusedAmount(false)}
              onChange={(e) => handleAmountChange(e.target.value, denom)}
              className="w-24 h-8 text-right text-gray-800 text-sm font-bold bg-gray-200 rounded-md p-1 focus:outline-none focus:ring-2 focus:ring-blue-500 no-spinner"
            />
            <span className="text-gray-500 text-xs">원</span>
          </div>
        </div>
      );
    };

    return (
      <div className="min-h-screen bg-slate-900 font-sans flex flex-col items-center justify-center py-4">
        {/* 전체 컨테이너는 max-w-sm으로 제한하여 PC 화면에서 너무 커지지 않게 합니다. */}
        <div className="w-full max-w-sm bg-slate-100 rounded-2xl shadow-xl p-4 space-y-3 transform transition-all duration-300">
          <div className="flex justify-between items-center mb-2">
            <h1 className="text-xl font-extrabold text-gray-800 pb-1">
              회수금 계산기
            </h1>
            <button
              onClick={handleReset}
              className="px-3 py-1 bg-slate-700 text-white font-bold text-sm rounded-lg shadow-md hover:bg-slate-600 transition-colors duration-200"
            >
              초기화
            </button>
          </div>

          {/* 마감 전 금고 잔액 - New Section */}
          <div className="bg-slate-800 rounded-xl p-3 shadow-lg text-white">
            <div className="flex justify-between items-center">
              <h2 className="text-lg font-bold">마감 전 금고 잔액</h2>
              <div className="flex items-center space-x-1">
                <input
                  type="text"
                  inputMode="numeric"
                  placeholder="0"
                  value={prevVaultBalance === '' ? '' : formatCurrency(parseInt(prevVaultBalance || '0'))}
                  onChange={(e) => setPrevVaultBalance(e.target.value.replace(/[^0-9]/g, ''))}
                  className="w-32 h-8 text-right text-xl font-extrabold bg-black text-amber-300 rounded-md p-1 focus:outline-none focus:ring-2 focus:ring-blue-500 no-spinner"
                />
                <span className="text-gray-300 text-xs">원</span>
              </div>
            </div>
          </div>

          {/* 지폐 섹션 */}
          <div className="bg-white rounded-xl p-2 shadow-md border border-gray-200">
            {denominations.filter(d => d.type === 'bill').map(renderDenominationItem)}
            <div className="mt-2 pt-2 flex justify-between items-center font-bold text-sm text-gray-800">
              <span>지폐 소계:</span>
              <span>{formatCurrency(totals.billTotal)}</span>
            </div>
          </div>

          {/* 동전 섹션 */}
          <div className="bg-white rounded-xl p-2 shadow-md border border-gray-200">
            {denominations.filter(d => d.type === 'coin').map(renderDenominationItem)}
            <div className="mt-2 pt-2 flex justify-between items-center font-bold text-sm text-gray-800">
              <span>동전 소계:</span>
              <span>{formatCurrency(totals.coinTotal)}</span>
            </div>
          </div>

          {/* 지폐/동전 합계 (모든 지폐와 동전의 총 합계) */}
          <div className="bg-slate-800 rounded-xl p-3 shadow-lg text-white">
            <div className="flex justify-between items-center">
              <h2 className="text-lg font-bold">지폐/동전 합계</h2>
              <span className="text-xl font-extrabold text-amber-300">
                {formatCurrency(totals.denominationGrandTotal)}
              </span>
            </div>
          </div>

          {/* 추가 항목 섹션 */}
          <div className="bg-white rounded-xl p-2 shadow-md border border-gray-200 space-y-1">
            <CoinReplenishmentItem
              value={coinReplenishment}
              onChange={setCoinReplenishment}
            />
            <SlipDiscrepancyItem
              value={slipDiscrepancy}
              type={slipDiscrepancySign}
              onChange={setSlipDiscrepancy}
              onTypeChange={setSlipDiscrepancySign}
            />
          </div>

          {/* 마감 후 금고 잔액 (최종 계산 결과) */}
          <div className="bg-slate-800 rounded-xl p-3 shadow-lg text-white">
            <div className="flex justify-between items-center">
              <h2 className="text-lg font-bold">마감 후 금고 잔액</h2>
              <span className="text-xl font-extrabold text-amber-300">
                {formatCurrency(totals.grandTotal)}
              </span>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Render the App
  const container = document.getElementById('root');
  const root = ReactDOM.createRoot(container);
  root.render(<App />);
</script>

<script>
  // Service Worker Registration
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js').then(registration => {
        console.log('SW registered: ', registration);
      }).catch(registrationError => {
        console.log('SW registration failed: ', registrationError);
      });
    });
  }
</script>

<!-- Inline manifest.json for a single file -->
<script type="application/json" id="manifest">
{
  "name": "회수금 계산기",
  "short_name": "계산기",
  "description": "간단한 회수금 계산기",
  "start_url": ".",
  "display": "standalone",
  "background_color": "#0f172a",
  "theme_color": "#0f172a",
  "icons": [
    {
      "src": "https://placehold.co/180x180/0f172a/fff?text=CC",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "https://placehold.co/180x180/0f172a/fff?text=CC",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
</script>

<!-- Inline service worker for a single file -->
<script id="sw-script">
  self.addEventListener('install', (event) => {
    event.waitUntil(
      caches.open('currency-calculator-v1').then((cache) => {
        return cache.addAll([
          '/',
          '/index.html',
          'https://unpkg.com/react@18/umd/react.production.min.js',
          'https://unpkg.com/react-dom@18/umd/react-dom.production.min.js',
          'https://unpkg.com/@babel/standalone/babel.min.js',
          'https://cdn.tailwindcss.com',
        ]);
      })
    );
    self.skipWaiting();
  });

  self.addEventListener('fetch', (event) => {
    event.respondWith(
      caches.match(event.request).then((response) => {
        return response || fetch(event.request);
      })
    );
  });
</script>
<script>
  // Dynamic SW file creation
  const swCode = document.getElementById('sw-script').textContent;
  const manifest = document.getElementById('manifest').textContent;
  
  const swBlob = new Blob([swCode], { type: 'application/javascript' });
  const manifestBlob = new Blob([manifest], { type: 'application/json' });

  const swUrl = URL.createObjectURL(swBlob);
  const manifestUrl = URL.createObjectURL(manifestBlob);
  
  const originalRegister = navigator.serviceWorker.register;
  const originalFetch = window.fetch;

  // Polyfill service worker registration
  navigator.serviceWorker.register = (path) => {
    if (path === '/sw.js') {
      return originalRegister.call(navigator.serviceWorker, swUrl);
    }
    return originalRegister.call(navigator.serviceWorker, path);
  };
  
  // Polyfill manifest fetch
  window.fetch = (input, init) => {
    if (input instanceof Request && input.url.endsWith('/manifest.json')) {
      return new Response(manifest, {
        headers: { 'Content-Type': 'application/json' }
      });
    } else if (typeof input === 'string' && input.url.endsWith('/manifest.json')) {
      return new Response(manifest, {
        headers: { 'Content-Type': 'application/json' }
      });
    }
    return originalFetch.call(window, input, init);
  };
  
</script>

</body>
</html>
